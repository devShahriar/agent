// Code generated by bpf2go; DO NOT EDIT.
//go:build linux

package tracer

import (
	"fmt"
	"runtime"

	"github.com/cilium/ebpf"
)

// bpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfObjects struct {
	TraceAccept4     *ebpf.Program `ebpf:"TraceAccept4"`
	TraceAccept4Exit *ebpf.Program `ebpf:"TraceAccept4Exit"`
	TraceConnect     *ebpf.Program `ebpf:"TraceConnect"`
	TraceWrite       *ebpf.Program `ebpf:"TraceWrite"`
	TraceRead        *ebpf.Program `ebpf:"TraceRead"`
	TraceReadRet     *ebpf.Program `ebpf:"TraceReadRet"`
	TraceClose       *ebpf.Program `ebpf:"TraceClose"`

	// Maps
	Events        *ebpf.Map `ebpf:"events"`
	EventStorage  *ebpf.Map `ebpf:"event_storage"`
	ConnState     *ebpf.Map `ebpf:"conn_state"`
	ProcessInfo   *ebpf.Map `ebpf:"process_info"`
	ActiveFds     *ebpf.Map `ebpf:"active_fds"`
	ActiveSockets *ebpf.Map `ebpf:"active_sockets"`
	SocketInfo    *ebpf.Map `ebpf:"socket_info"`
	ReadArgsMap   *ebpf.Map `ebpf:"read_args_map"`
}

// bpfSpecs contains the spec objects after they have been loaded from the ELF file.
//
// It can be passed to ebpf.CollectionSpec.LoadAndAssign.
type bpfSpec struct {
	TraceAccept4     *ebpf.ProgramSpec `ebpf:"TraceAccept4"`
	TraceAccept4Exit *ebpf.ProgramSpec `ebpf:"TraceAccept4Exit"`
	TraceConnect     *ebpf.ProgramSpec `ebpf:"TraceConnect"`
	TraceWrite       *ebpf.ProgramSpec `ebpf:"TraceWrite"`
	TraceRead        *ebpf.ProgramSpec `ebpf:"TraceRead"`
	TraceReadRet     *ebpf.ProgramSpec `ebpf:"TraceReadRet"`
	TraceClose       *ebpf.ProgramSpec `ebpf:"TraceClose"`

	// Maps
	Events        *ebpf.MapSpec `ebpf:"events"`
	EventStorage  *ebpf.MapSpec `ebpf:"event_storage"`
	ConnState     *ebpf.MapSpec `ebpf:"conn_state"`
	ProcessInfo   *ebpf.MapSpec `ebpf:"process_info"`
	ActiveFds     *ebpf.MapSpec `ebpf:"active_fds"`
	ActiveSockets *ebpf.MapSpec `ebpf:"active_sockets"`
	SocketInfo    *ebpf.MapSpec `ebpf:"socket_info"`
	ReadArgsMap   *ebpf.MapSpec `ebpf:"read_args_map"`
}

// loadBpfObjects loads bpf objects into the kernel.
func loadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	// For MacOS, we'll use custom loading
	if runtime.GOOS == "darwin" {
		// On MacOS, eBPF is limited/not supported
		// Return a dummy implementation or error indicating not supported
		return fmt.Errorf("BPF tracing is not fully supported on macOS")
	}

	// For Linux, load from the compiled object file
	spec, err := ebpf.LoadCollectionSpec("bpf_bpfel.o")
	if err != nil {
		return fmt.Errorf("loading BPF collection spec: %w", err)
	}

	if err := spec.LoadAndAssign(obj, opts); err != nil {
		return fmt.Errorf("loading BPF objects: %w", err)
	}

	return nil
}

// Close releases all resources held by the loaded BPF objects
func (o *bpfObjects) Close() error {
	// Close all maps
	maps := []*ebpf.Map{
		o.Events,
		o.EventStorage,
		o.ConnState,
		o.ProcessInfo,
		o.ActiveFds,
		o.ActiveSockets,
		o.SocketInfo,
		o.ReadArgsMap,
	}

	for _, m := range maps {
		if m != nil {
			m.Close()
		}
	}

	// Close all programs
	programs := []*ebpf.Program{
		o.TraceAccept4,
		o.TraceAccept4Exit,
		o.TraceConnect,
		o.TraceWrite,
		o.TraceRead,
		o.TraceReadRet,
		o.TraceClose,
	}

	for _, p := range programs {
		if p != nil {
			p.Close()
		}
	}

	return nil
}
